# inorder

CPU симулятор In-Order-Execution'а.

## Язык

Симулятор работает только со специальным языком. Язык не совсем существует, поэтому внизу будут все доступные в нём команды. За основу был взят RISC-ассемблер MISC:


| Команда | Аргументы       | Что делает    |
|-------------|------------|-------------|
| jmp         | `label`          | `Jump to 'label'`         |
| jne         | `t1, t2, label`  | `Jump to 'label' if t1 != t2`         |
| jie         | `t1, t2, label`  | `Jump to 'label' if t1 == t2`         |
| jge         | `t1, t2, label`  | `Jump to 'label' if t1 >= t2`         |
| jgt         | `t1, t2, label`  | `Jump to 'label' if t1 > t2`         |
| jle         | `t1, t2, label`  | `Jump to 'label' if t1 <= t2`         |
| jlt         | `t1, t2, label`  | `Jump to 'label' if t1 < t2`         |
| sw          | `t1, X`          | `X = t1`         |
| lw          | `t1, X`          | `t1 = X`         |
| sw          | `t1, X`          | `X = t1`         |
| li          | `t1, #value`     | `li t1, #5` (t1 = 5) |
| shl         | `t1, #value`     | `t1 = (t1 << value)`   |
| shr         | `t1, #value`     | `t1 = (t1 >> value)`   |
| add         | `t1, t2, t3`     | `t1 = t2 + t3`   |
| addi        | `t1, t2, #value` | `addi t0, t1, #5` (t0 = t1 + 5)   |
| sub         | `t1, t2, t3`     | `t1 = t2 - t3`   |
| subi        | `t1, t2, #value` | `subi t0, t1, #5` (t0 = t1 - 5)   |
| mul         | `t1, t2, t3`     | `t1 = t2 * t3`   |
| muli        | `t1, t2, #value` | `muli t0, t1, #5` (t0 = t1 * 5)   |
| div         | `t1, t2, t3`     | `t1 = t2 // t3`  |
| divi        | `t1, t2, #value` | `divi t0, t1, #5` (t0 = t1 // 5)   |
| and         | `t1, t2, t3`     | `t1 = t2 & t3`  |
| andi        | `t1, t2, #value` | `t1 = t2 & value`   |
| or          | `t1, t2, t3`     | `t1 = t2 \| t3`  |
| ori         | `t1, t2, #value` | `t1 = t2 \| value`   |
| xor          | `t1, t2, t3`     | `t1 = t2 ^ t3`  |
| xori         | `t1, t2, #value` | `t1 = t2 ^ value`   |

Обратитесь к [примерам](test/test_inorder.py) для подробного понимания и ознакомления.

## Симулятор

Симулятор принимает конфиг, задающий стоимость каждой операции, в каком блоке она выполняется и количество блоков.
Симулятор также полностью выполняет код, чтобы проверить его валидность.

Лейблы в языке есть, а вот секций нет. Память симулятора состоит из двух python-dict'ов: `registers` и `memory`. По дефолту регистры в нашей системе это `t0, t1, t2, t3, t4` и так далее. Из них специальный -`t0` он указывает на подобие стека, которое для простоты мы называем *нестэк*.

Тем не менее, если вы хотите создать переменную, ничего вам не мешает просто назвать регистр как вы захотите. Это вполне сработает.

Запуск: 
```
pytest -s


================================================================================
                        Результаты симуляции (Таймлайн)                         
================================================================================
Инструкция     | Start |   End | Таймлайн (Циклы 1..11)
---------------+---------+-------+------------
lw t1, 0(t0)   |     0 |     4 | #####······
add t2, t1, t1 |     5 |     5 | ·····#·····
sw t2, 4(t0)   |     6 |    10 | ······#####

ИТОГО ЦИКЛОВ: 11

================================================================================
                        Результаты симуляции (Таймлайн)                         
================================================================================
Инструкция     | Start |   End | Таймлайн (Циклы 1..26)
---------------+---------+-------+---------------------------
lw t1, 0(t0)   |     0 |     4 | #####·····················
lw t2, 4(t0)   |     5 |     9 | ·····#####················
add t3, t1, t2 |    10 |    10 | ··········#···············
lw t4, 8(t0)   |    10 |    14 | ··········#####···········
add t5, t1, t4 |    15 |    15 | ···············#··········
sw t5, 16(t0)  |    16 |    20 | ················#####·····
sw t3, 12(t0)  |    21 |    25 | ·····················#####

ИТОГО ЦИКЛОВ: 26
```

